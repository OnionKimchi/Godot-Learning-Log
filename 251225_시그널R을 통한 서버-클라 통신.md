# TIL 251225 — Godot(.NET) ↔ .NET 서버 SignalR 연결 성공 기록

## 오늘 한 줄 요약

* **SignalR**은 **.NET 서버(ASP.NET Core)** 와 **.NET 클라이언트(Godot C#)** 가 둘 다 지원하는 **실시간 통신 방식**이고,
* Godot(.NET)에서 **SignalR Client로 허브에 연결**한 뒤,
* 서버가 보내는 메시지를 받아서 **디버그 로그로 확인**했고,
* 클라 → 서버로 문자열을 보내고 서버가 다시 JSON 응답(에코+시간)을 보내는 **왕복 통신**까지 성공했다.

---

## 목표

1. Godot(.NET)에서 SignalR 허브에 연결
2. 서버가 보내는 메시지 수신 로그 확인
3. 클라가 서버 메서드 호출(JoinGame / SendTestMessage)
4. 서버 응답 수신 로그 확인

---

## 사용한 스택/전제

* Godot: **4.4.1 stable mono** (C# 사용 가능한 .NET 버전)
* 서버: **ASP.NET Core + SignalR Hub**
* 통신: `HubConnection` 기반 SignalR 클라이언트
* 개발 환경: 로컬 HTTPS (`https://localhost:5001/gamehub`)

  * 로컬 개발 인증서 문제 때문에 **SSL 인증서 검증 무시** 옵션 사용(개발용)

---

## 구현 개념 정리 (왜 SignalR인가)

* 카드게임은 “상태 변화 이벤트”가 많다: 턴 시작/종료, 카드 사용, 효과 발동, 데미지, 드로우 등
* HTTP 폴링은 번거롭고 지연/낭비가 생김
* SignalR은 WebSocket 기반으로 **서버→클라 푸시**가 쉬워서 카드게임에 잘 맞는다
* 중요한 설계: **서버 권위(Server-authoritative)**

  * 클라는 “표현 + 선택”만 하고
  * 룰/검증/결과는 서버가 결정하는 구조가 안정적

---

## Godot 클라이언트 코드 핵심 (GameClient.cs)

### 역할

* 지금 단계의 GameClient는 “게임 로직”이 아니라 **연결/호출/수신 테스트용 통신 뼈대**
* 하는 일:

  * 연결 시작
  * 서버 이벤트 구독
  * 허브 메서드 호출
  * 받은 데이터 출력

### 핵심 코드 흐름

* `_Ready()`에서 `ConnectToServer()` 호출
* `HubConnectionBuilder().WithUrl(...).WithAutomaticReconnect().Build()`
* 서버→클라 이벤트 구독:

  * `ConnectionConfirmed`
  * `TestResponse`
* 연결 시작: `StartAsync()`
* 서버 메서드 호출: `InvokeAsync("JoinGame", ...)`, `InvokeAsync("SendTestMessage", ...)`

---

## 설정/빌드에서 막혔던 포인트들 (재현용 체크리스트)

### 1) “Main Scene” 미지정 팝업

증상: 실행 시

> “No main scene has ever been defined…”

해결:

* `Project Settings → Application → Run → Main Scene` 에 메인 씬 지정
* 또는 팝업에서 “현재 선택 / 선택”으로 지정

---

### 2) Godot 빌드 버튼 눌렀는데 회색 빈 화면

증상:

* Godot 내부 빌드 UI가 로그 없이 비는 경우가 있음

해결:

* **터미널에서 직접 빌드**로 진실을 확인하는 게 제일 확실했음

  ```bash
  dotnet build
  ```
* 실제로는 빌드가 정상 성공했고 DLL 생성됨:
  `... .godot\mono\temp\bin\Debug\...dll`

---

### 3) `Microsoft.AspNetCore.SignalR.Client` / `HubConnection`을 못 찾는 에러

증상:

* `Microsoft` 네임스페이스에 `AspNetCore` 없음
* `HubConnection` 타입 못 찾음

원인:

* Godot C# 프로젝트에 **SignalR Client NuGet 패키지가 없음**

해결:

* 프로젝트 폴더( `.csproj` 있는 위치 )에서

  ```bash
  dotnet add package Microsoft.AspNetCore.SignalR.Client
  ```
* 그 다음

  ```bash
  dotnet build
  ```
* 그리고 Godot로 돌아와 `Project → Tools → C# → Build`

---

### 4) (진짜 중요) 파일명과 클래스명 불일치로 스크립트가 실행 안 되는 문제

증상:

* 스크립트를 노드에 붙였는데 `_Ready()` 로그가 안 찍힘
* Output에는 엔진 시작 로그만 있고 조용함

원인:

* 파일명: `CameClient.cs`
* 클래스명: `GameClient`
* Godot C#에서 이 불일치가 런타임 인식/로드를 꼬이게 만들 수 있음

해결:

* **파일명과 클래스명을 일치**

  * `GameClient.cs` ↔ `public partial class GameClient : Node`
* 이후 다시 빌드

---

### 5) “씬에 스크립트를 올려야 실행된다”

중요 개념:

* C# 파일이 프로젝트에 있어도 자동으로 실행되지 않음
* **씬 트리에 실제 노드로 존재**해야 `_Ready()`가 돈다

실행 확인 방법:

* 메인 씬에 `Node` 추가
* 그 노드에 `GameClient` 스크립트 붙이기
* 실행(▶) 후 Output 로그 확인

---

## 오늘 성공 로그 (정상 동작 기준)

성공 시 출력 예:

* `SignalR 연결 시도 중...`
* `서버 연결 성공!`
* 서버가 내려주는 JSON 데이터(게임 연결 확인)
* `서버 응답: ...` (에코/시간 포함)

이 로그가 나왔다는 건:

* 연결(Handshake) 성공
* 서버 이벤트 수신 성공
* 클라→서버 호출 성공
* 서버→클라 응답 수신 성공
  까지 전부 통과했다는 뜻

---

## 배운 점 (핵심 인사이트)

1. SignalR은 **.NET↔.NET** 조합에서 특히 매끄럽다
2. Godot(.NET)은 NuGet 패키지 설치가 가능하지만, **패키지 추가/복원/빌드는 터미널이 가장 확실**
3. “메인 씬 지정” + “씬에 노드로 올리기”가 Godot 실행의 기본
4. 파일명/클래스명 불일치는 “조용히 안 되는” 고약한 원인이 될 수 있다
5. 지금 단계에서 클라는 로직을 넣기보다

   * “서버에서 내려준 선택지 하나 고르기”
   * “선택을 서버에 보내기”
   * “결과 이벤트를 받아 연출하기”
     정도만 해도 충분하다 (서버 권위 설계에 잘 맞음)

---

## 다음에 재사용할 때 “최소 실행 절차” (초압축)

1. Godot .NET 프로젝트 생성/열기
2. `.csproj` 폴더에서

   ```bash
   dotnet add package Microsoft.AspNetCore.SignalR.Client
   dotnet build
   ```
3. 메인 씬 지정
4. 메인 씬에 `Node` 만들고 `GameClient.cs` 붙이기
5. 파일명=클래스명 확인
6. 실행(▶) → Output 로그 확인

